<!DOCTYPE html>
<html>
<head>
    <style>
        *,*:before,*:after,ul,li,a,button,input,h1,h2,h3,h4,h5,h6,p,img,image,svg,path,g,
        canvas {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background-color: transparent;
            border: none;
            text-decoration: none;
            font-family: "Roboto";
            -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                    user-select: none;
            list-style: none;
            position: relative;
        }

        html,
        body {
            width: 100%;
            height: inherit;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: row;
            margin: 0;
            padding: 0;
            background-color: #FAFAFA;
            font-family: "Roboto";
        }

        .button {
            width: 150px;
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: row;
            border: 3px solid #1e90ff;
        }
        .button.disabled {
            pointer-events: none;
            opacity: 0.5;
        }
        .button--play {
            border-radius: 50%;
        }
        .button--play .button__shape {
            width: 25px;
            height: 75px;
            background: #1e90ff;
            transition: 0.3s ease-in-out;
        }
        .button--play .button__shape--one {
            -webkit-clip-path: polygon(0 0, 100% 25%, 100% 75%, 0% 100%);
            transform: translateX(5px);
        }
        .button--play .button__shape--two {
            -webkit-clip-path: polygon(0 25%, 100% 50%, 100% 50%, 0 75%);
            transform: translateX(4.9px);
        }
        .button--play.button--active .button__shape--one {
            -webkit-clip-path: polygon(0 15%, 50% 15%, 50% 85%, 0% 85%);
            transform: translateX(0px);
        }
        .button--play.button--active .button__shape--two {
            -webkit-clip-path: polygon(50% 15%, 100% 15%, 100% 85%, 50% 85%);
            transform: translateX(0px);
        }
    </style>
</head>
<body>

<audio id="audioTag" loop onplay="displayPause()" onpause="displayPlay()">
    <source src="glories.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>

<div class="button button--play disabled" id="pb">
  <div class="button__shape button__shape--one"></div>
  <div class="button__shape button__shape--two"></div>
</div>

<p id="cTime"></p>

<script>
const unixReferenceTime = 0;
const audio = document.getElementById("audioTag");
const pb = document.getElementById("pb");
pb.addEventListener('click', playpause);

 let metadataReady = false;

  audio.addEventListener('loadedmetadata', () => {
    metadataReady = true;
    if(serverOffset_ms) enablePlay();
  });

let newServerOffset_ms;
let serverOffset_ms;
let minOffset = -999999;
let maxOffset = 999999;
let ws;
let syncInterval;

function connectWebSocket() {

    let protocol = window.location.protocol.startsWith('https') ? 'wss' : 'ws';
    let wHost = window.location.host;
    ws = new WebSocket(protocol+'://'+wHost);

    //ws = new WebSocket('wss://gloriesaudio.onrender.com');

    ws.onopen = async () => {
        console.log('Connected. Waiting for sync...');
        computeOffset();
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'serverTime') {
            let t3 = Date.now();
            let localMaxOffset = data.serverTime_ms - data.clientTime_ms;
            let localMinOffset = data.serverTime_ms - t3;
            if(localMaxOffset < maxOffset ) maxOffset = localMaxOffset;
            if(localMinOffset > minOffset ) minOffset = localMinOffset;
            if(minOffset > maxOffset) newServerOffset_ms = 0;
            else newServerOffset_ms = (maxOffset + minOffset) / 2;
        }
    };

    ws.onerror = () => {
       console.error('Server connection failed. Check if server is running.');
    };
}

async function computeOffset(){
    minOffset = -999999;
    maxOffset = 999999;
    newServerOffset_ms = null;
    for(let i = 0; i < 3; i++) 
        await getServerOffset();
    while(newServerOffset_ms === null) 
        await delay(500);
    if(!serverOffset_ms || Math.abs(serverOffset_ms - newServerOffset_ms) > 0.2){
        serverOffset_ms = newServerOffset_ms;
        if(!audio.paused) sync();
    }
    if(pb.classList.contains("disabled") && metadataReady) enablePlay();
}

const delay = ms => new Promise(res => setTimeout(res, ms));
async function getServerOffset(){
    if(!ws || ws.readyState !== WebSocket.OPEN) return;
    ws.send(JSON.stringify({
        type: 'getServerTime',
        t1: Date.now()
    }));
    await delay(500);
}

function sync() {
    if (!audioUnlocked) return;
    console.log("pre ct: "+audio.currentTime);
    let duration_ms = audio.duration * 1000;
    let timeToSeek = ((Date.now() + serverOffset_ms - unixReferenceTime) % duration_ms) / 1000;
    audio.currentTime = timeToSeek;

    console.log("to seek: "+timeToSeek);
    console.log("post ct: "+audio.currentTime);
    
}

let audioUnlocked = false;
async function playpause() {
    if (!audioUnlocked) {
        try {
            await audio.play();
            audio.pause();
            audioUnlocked = true;
        } catch (e) {
            console.error(e);
            return;
        }
    }

	if(audio.paused) {
        sync();
        syncInterval = setInterval(computeOffset, 20000);
        await audio.play();
    } else {
        audio.pause();
        clearInterval(syncInterval);
    }
}

function displayPause() {
    pb.classList.add("button--active")
}

function displayPlay() {
    pb.classList.remove("button--active")
}

let p = document.getElementById("cTime");
function showTime() {
    p.innerHTML = audio.currentTime;
}
function enablePlay() {
    pb.classList.remove("disabled");
    //sync();
    //setInterval(sync, 10000);
    //setInterval(showTime, 50);
}

connectWebSocket();
</script>

</body>
</html>
